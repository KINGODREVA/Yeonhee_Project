#!/usr/bin/python3
# -*- coding: utf-8 -*-

from geometry_msgs.msg import Twist
from PySide2.QtWidgets import *
from PySide2.QtCore import *
import rospy
import numpy as np
import cv2

frame_crop_x1 = 0
frame_crop_y1 = 120
frame_crop_x2 = 639
frame_crop_y2 = 479

minLineLength = 30
maxLineGap = 15

speed = 0
angle = 0

cap = cv2.VideoCapture(0)

class ButtonWindow(QMainWindow):
    def __init__(self):
        super(ButtonWindow, self).__init__()

        self.button_forward = QPushButton("Move Forward", self)
        self.button_forward.setGeometry(10, 10, 200, 30)
        self.button_forward.clicked.connect(self.move_forward)

        self.button_backward = QPushButton("Move Backward", self)
        self.button_backward.setGeometry(10, 50, 200, 30)
        self.button_backward.clicked.connect(self.move_backward)

        self.button_stop = QPushButton("Stop", self)
        self.button_stop.setGeometry(10, 90, 200, 30)
        self.button_stop.clicked.connect(self.stop_movement)

    @Slot()
    def move_forward(self):
        global speed, angle
        speed = 0.5
        angle = 0.0

    @Slot()
    def move_backward(self):
        global speed, angle
        speed = -0.5
        angle = 0.0

    @Slot()
    def stop_movement(self):
        global speed, angle
        speed = 0.0
        angle = 0.0

def cam_read():
    global frame, gray
    ret, frame = cap.read()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

def cam_use_line():
    global frame, theta
    blurred = gray[frame_crop_y1:frame_crop_y2, frame_crop_x1:frame_crop_x2]
    blurred = cv2.boxFilter(blurred, ddepth=-1, ksize=(31, 31))
    retval2, blurred = cv2.threshold(blurred, 100, 255, cv2.THRESH_BINARY)
    edged = cv2.Canny(blurred, 85, 85)
    lines = cv2.HoughLinesP(edged, 1, np.pi / 180, 10, minLineLength, maxLineGap)
    max_diff = 1000
    final_x = 0
    if lines is not None:
        add_line = 0
        for line in lines:
            x1, y1, x2, y2 = line[0]
            cv2.line(frame, (x1 + frame_crop_x1, y1 + frame_crop_y1), (x2 + frame_crop_x1, y2 + frame_crop_y1),
                     (0, 255, 0), 3)
            mid_point = (x1 + x2) / 2
            diff = abs((640 / 2) - mid_point)
            if max_diff > diff:
                max_diff = diff
                final_x = mid_point
            add_line = add_line + final_x
        average_x = add_line / len(lines)
        if int(average_x) != 0:
            frame = cv2.circle(frame, (int(average_x), int((frame_crop_y1 + frame_crop_y2) / 2)), 5, (0, 0, 255), -1)
            frame = cv2.rectangle(frame, (int(frame_crop_x1), int(frame_crop_y1)), (int(frame_crop_x2), int(frame_crop_y2)),
                                  (0, 0, 255), 1)
        theta = int((int(average_x) - 320.0) / 640.0 * 100)
    if lines is None:
        theta = -50

def talker():
    global speed, angle
    rospy.init_node("line_follower")
    pub = rospy.Publisher("/cmd_vel", Twist, queue_size=10)
    msg = Twist()

    while not rospy.is_shutdown():
        msg.linear.x = speed
        msg.angular.z = angle
        pub.publish(msg)

        cam_read()
        cam_use_line()

        cv2.imshow('frame', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

if __name__ == "__main__":
    try:
        rospy.init_node("line_follower")
        app = QApplication([])
        window = ButtonWindow()
        window.show()
        talker()
        app.exec_()
    except rospy.ROSInterruptException:
        pass
